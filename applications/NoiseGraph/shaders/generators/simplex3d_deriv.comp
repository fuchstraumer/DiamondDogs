const int grad_3d_lut[256][3] =
{
	{ 0,0, 1 },
	{ 0,0,-1 },
	{ 0, 1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 },
	{ 1,0,0 },
	{ -1,0,0 },
	{ 0,0,1 },
	{ 0,0,-1 },
	{ 0,1,0 },
	{ 0,-1,0 }
};

float simplex3d(in float px, in float py, in float pz, in int seed, out vec3 deriv){
	const float F3 = 0.333333333f;
	const float G3 = 0.166666667f;

	// Skew input space about and find our simplex cell and simplex coordinates in ijk space
	vec3 s = vec3(px, py, pz) + ((px + py + pz) * F3);
	ivec3 i_s = ivec3(floorf(s.x), floorf(s.y), floorf(s.z));

	// First positional coordinate
	vec3 p0;
	p0.x = px - (i_s.x - ((i_s.x + i_s.y + i_s.z) * G3));
	p0.y = py - (i_s.y - ((i_s.x + i_s.y + i_s.z) * G3));
	p0.z = pz - (i_s.z - ((i_s.x + i_s.y + i_s.z) * G3));

	ivec3 i1, i2;

	if (p0.x >= p0.y) {
		if (p0.y >= p0.z) {
			i1.x = 1;
			i1.y = 0;
			i1.z = 0;
			i2.x = 1;
			i2.y = 1;
			i2.z = 0;
		}
		else if (p0.x >= p0.z) {
			i1.x = 1;
			i1.y = 0;
			i1.z = 0;
			i2.x = 1;
			i2.y = 0;
			i2.z = 1;
		}
		else {
			i1.x = 0;
			i1.y = 0;
			i1.z = 1;
			i2.x = 1;
			i2.y = 0;
			i2.z = 1;
		}
	}
	// If p0.x < p0.y
	else {
		if (p0.y < p0.z) {
			i1.x = 0;
			i1.y = 0;
			i1.z = 1;
			i2.x = 0;
			i2.y = 1;
			i2.z = 1;
		}
		else if (p0.x < p0.z) {
			i1.x = 0;
			i1.y = 1;
			i1.z = 0;
			i2.x = 0;
			i2.y = 1;
			i2.z = 1;
		}
		else {
			i1.x = 0;
			i1.y = 1;
			i1.z = 0;
			i2.x = 1;
			i2.y = 1;
			i2.z = 0;
		}
	}

	// Get simplex coords in xyz coords
	vec3 p1(p0.x - i1.x + G3, p0.y - i1.y + G3, p0.z - i1.z + G3);
	vec3 p2(p0.x - i2.x + (2.0f * G3), p0.y - i2.y + (2.0f * G3), p0.z - i2.z + (2.0f * G3));
	vec3 p3(p0.x - 1.0f + (3.0f * G3), p0.y - 1.0f + (3.0f * G3), p0.z - 1.0f + (3.0f * G3));

	uint h0 = hash_3d(i_s.x, i_s.y, i_s.z, seed);
	uint h1 = hash_3d(i_s.x + i1.x, i_s.y + i1.y, i_s.z + i1.z, seed);
	uint h2 = hash_3d(i_s.x + i2.x, i_s.y + i2.y, i_s.z + i2.z, seed);
	uint h3 = hash_3d(i_s.x + 1, i_s.y + 1, i_s.z + 1, seed);

	// Get gradient vectors using hash coordinates and get contributions from each of four corners.
	vec3 g0(grad_3d_lut[h0][0], grad_3d_lut[h0][1], grad_3d_lut[h0][2]);
	vec3 g1(grad_3d_lut[h1][0], grad_3d_lut[h1][1], grad_3d_lut[h1][2]);
	vec3 g2(grad_3d_lut[h2][0], grad_3d_lut[h2][1], grad_3d_lut[h2][2]);
	vec3 g3(grad_3d_lut[h3][0], grad_3d_lut[h3][1], grad_3d_lut[h3][2]);


	float t0, t1, t2, t3;
	// Squares of t0-t3.
	volatile float t0_2, t1_2, t2_2, t3_2;

	// Actual contribution to final result
	float n0, n1, n2, n3;

	// First corner
	t0 = 0.60f - p0.x*p0.x - p0.y*p0.y - p0.z*p0.z;
	if (t0 < 0.0f) {
		t0 = t0_2 = n0 = 0.0f;
		g0 = vec3(0.0f, 0.0f, 0.0f);
	}
	else {
		t0_2 = t0 * t0;
		n0 = (t0_2 * t0_2) * (g0.x*p0.x + g0.y*p0.y + g0.z*p0.z);
	}

	// Second corner
	t1 = 0.60f - p1.x*p1.x - p1.y*p1.y - p1.z*p1.z;
	if (t1 < 0.0f) {
		t1 = t1_2 = n1 = 0.0f;
		g1 = vec3(0.0f, 0.0f, 0.0f);
	}
	else {
		t1_2 = t1 * t1;
		n1 = (t1_2 * t1_2) * (g1.x*p1.x + g1.y*p1.y + g1.z*p1.z);
	}

	// Third corner.
	t2 = 0.60f - p2.x*p2.x - p2.y*p2.y - p2.z*p2.z;
	if (t2 < 0.0f) {
		t2 = t2_2 = n2 = 0.0f;
		g2 = vec3(0.0f, 0.0f, 0.0f);
	}
	else {
		t2_2 = t2 * t2;
		n2 = (t2_2 * t2_2) * (g2.x*p2.x + g2.y*p2.y + g2.z*p2.z);
	}

	// Fourth and final corner.
	t3 = 0.60f - p3.x*p3.x - p3.y*p3.y - p3.z*p3.z;
	if (t3 < 0.0f) {
		t3 = t3_2 = n3 = 0.0f;
		g3 = vec3(0.0f, 0.0f, 0.0f);
	}
	else {
		t3_2 = t3 * t3;
		n3 = (t3_2 * t3_2) * (g3.x*p3.x + g3.y*p3.y + g3.z*p3.z);
	}

	// Add all contributions and scale.
	float result = 28.0f * (n0 + n1 + n2 + n3);

	// Calculate derivative, if desired (i.e deriv != nullptr)
	{
		volatile float tmp0, tmp1, tmp2, tmp3;
		tmp0 = t0_2 * t0 * (g0.x*p0.x + g0.y*p0.y + g0.z*p0.z);
		deriv.x = tmp0 * p0.x;
		deriv.y = tmp0 * p0.y;
		deriv.z = tmp0 * p0.z;
		tmp1 = t1_2 * t1 * (g1.x*p1.x + g1.y*p1.y + g1.z*p1.z);
		deriv.x += tmp1 * p1.x;
		deriv.y += tmp1 * p1.y;
		deriv.z += tmp1 * p1.z;
		tmp2 = t2_2 * t2 * (g2.x*p2.x + g2.y*p2.y + g2.z*p2.z);
		deriv.x += tmp2 * p2.x;
		deriv.y += tmp2 * p2.y;
		deriv.z += tmp2 * p2.z;
		tmp3 = t3_2 * t3 * (g3.x*p3.x + g3.y*p3.y + g3.z*p3.z);
		deriv.x += tmp3 * p3.x;
		deriv.y += tmp3 * p3.y;
		deriv.z += tmp3 * p3.z;
		deriv *= -8.0f;
		g0 *= (t0_2 * t0_2);
		g1 *= (t1_2 * t1_2);
		g2 *= (t2_2 * t2_2);
		g3 *= (t3_2 * t3_2);
		deriv += (g0 + g1 + g2 + g3);
		deriv *= 28.0f;
	}

	return result;
}