#version 450 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

// minimum max dimensionality in xy is 128, process textures in chunks of that size.
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std140, binding = 0) buffer input_buffer {
	vec2 in_data[];
};

layout(std140, binding = 1) buffer output_buffer {
	vec2 out_data[];
};


layout(constant_id = 0) const int sampleGridSize = 37;
layout(constant_id = 1) const int meshGridSize = sampleGridSize - 5;
layout(constant_id = 2) const int gridX = 0;
layout(constant_id = 3) const int gridY = 0;


void main() {

	uint i, j;
	i = gl_GlobalInvocationID.x;
	j = gl_GlobalInvocationID.y;

	if(i >= sampleGridSize || j >= sampleGridSize) {
		return;
	}

	int parent_x = 1 + (gridX % 2) * (meshGridSize / 2);
	int parent_y = 1 + (gridY % 2) * (meshGridSize / 2);

	if(j % 2 == 0) {
		if(i % 2 == 0) {
			output_data.data[i + (j * sampleGridSize)] = 
			vec2(input_data.data[i / 2 + parent_x + (j /2 + parent_y) * sampleGridSize].x, input_data.data[i / 2 + parent_x + (j /2 + parent_y) * sampleGridSize].x);
		}
		else {
			vec4 z;
			z.x = input_data.data[i / 2 + parent_x + (j / 2 - 1 + parent_y) * sampleGridSize].x;
			z.y = input_data.data[i / 2 + parent_x + (j / 2 + parent_y) * sampleGridSize].x;
			z.z = input_data.data[i / 2 + parent_x + (j / 2 + 1 + parent_y) * sampleGridSize].x;
			z.w = input_data.data[i / 2 + parent_x + (j / 2 + 2 + parent_y) * sampleGridSize].x;
			output_data.data[i + (j * sampleGridSize)] = 
			vec2(((z.y + z.z) * 9.0f - (z.x + z.w)) / 16.0f, input_data.data[i / 2 + parent_x + (j / 2 + parent_y) * sampleGridSize].x);
		}
	}
	else {
		if(i % 2 == 0) {
			vec4 z;
			z.x = input_data.data[i / 2 + parent_x - 1 + (j / 2 + parent_y) * sampleGridSize].x;
			z.y = input_data.data[i / 2 + parent_x + (j / 2 + parent_y) * sampleGridSize].x;
			z.z = input_data.data[i / 2 + parent_x + 1 + (j / 2 + parent_y) * sampleGridSize].x;
			z.w = input_data.data[i / 2 + parent_x + 2 + (j / 2 + parent_y) * sampleGridSize].x;
			output_data.data[i + (j * sampleGridSize)] = 
			vec2(((z.y + z.z) * 9.0f - (z.x + z.w)) / 16.0f, input_data.data[i / 2 + parent_x + (j /2 + parent_y) * sampleGridSize].x);
		}
		else {
			int dI, dJ;
			float sum = 0.0f;
			for(dJ = -1; dJ <= 2; ++dJ) {
				float f = (dJ == -1 || dJ == 2) ? (-1.0f / 16.0f) : (9.0f / 16.0f);
				for(dI = -1; dI <= 2; ++dI) {
					float g = (dI == -1 || dI == 2) ? (-1.0f / 16.0f) : (9.0f / 16.0f);
					sum += f * g * input_data.data[i / 2 + dI + parent_x + (j / 2 + dJ + parent_y) * sampleGridSize].x;
				}
			}
			output_data.data[i + (j * sampleGridSize)] = 
			vec2(sum, input_data.data[i / 2 + parent_x + (j / 2 + parent_y) * sampleGridSize].x);
		}
	}
		
		out_data[i + (j * sampleGridSize)] = vec2(1.0f, 0.0f);
	
}