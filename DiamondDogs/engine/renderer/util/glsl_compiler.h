#pragma once
#ifndef VULPES_GLSL_COMPILER_H
#define VULPES_GLSL_COMPILER_H

#include "stdafx.h"
#include "../objects/shader_object.h"

namespace vulpes {

	static void find_includes(std::string& input, std::vector<std::string>& output) {
		static const std::basic_regex<char> re("^[ ]*#[ ]*include[ ]+[\"<](.*)[\">].*");
		std::stringstream input_stream;
		input_stream << input;
		std::smatch matches;
		// Current line
		std::string line;
		while (std::getline(input_stream, line)) {
			if (std::regex_search(line, matches, re)) {
				std::string include_file = matches[1];
				std::string include_string;
				std::ifstream include_stream;
				// Try to open included file.
				try {
					std::string path = "./shaders/include/" + include_file;
					include_stream.open(path);
					std::stringstream tmp;
					tmp << include_stream.rdbuf();
					include_string = tmp.str();
					include_stream.close();
				}
				catch (std::ifstream::failure e) {
					std::cerr << "ERROR::SHADER::INCLUDED_FILE_NOT_SUCCESFULLY_READ: " << include_file << std::endl;
				}
				output.push_back(include_string);
				input.erase(matches.position(), matches.position() + matches.length());
			}
		}
	}

	static void find_defines(std::string& input, std::vector<std::string>& output) {
		static const std::basic_regex<char> re("^[ ]*#[ ]*define[ ]+[\"<](.*)[\">].*");
		std::stringstream input_stream;
		input_stream << input;
		std::smatch matches;
		// Current line
		std::string line;
		while (std::getline(input_stream, line)) {
			if (std::regex_search(line, matches, re)) {
				std::string define_item = matches[1];
				output.push_back(define_item);
				input.erase(matches.position(), matches.position() + matches.length());
			}
		}
	}

	static std::string import_file(const std::string& filename) {
		std::ifstream shader_file;
		std::string result;
		try {
			shader_file.open(filename);
			std::stringstream str_buf;
			str_buf << shader_file.rdbuf();
			result = str_buf.str();
			shader_file.close();
		}
		catch (std::ifstream::failure e) {
			std::cerr << "ERROR::VULPES::UTIL::GLSL_COMPILER: Input shader file " << filename << " not found or failed to read." << std::endl;
		}
		return result;
	}

	enum class profile {
		CORE,
		COMPATABILITY,
		DEBUG,
	};

	static std::string profile_string(const profile& prof) {
		if (prof == profile::CORE) {
			return std::string(" core\n");
		}
		else if (prof == profile::COMPATABILITY) {
			return std::string(" compatability\n");
		}
		else if (prof == profile::DEBUG) {
			return std::string(" debug\n");
		}
	}
	
	struct compiler {

		// Used to find/retrieve shader objects, where first entry is type of shader and second is handle/name of that shader object
		using shaders_map = std::unordered_map<GLenum, GLuint>;
			
		compiler(profile _prof, unsigned int _version) : prof(_prof), version(_version) {}

		template<typename shader_type>
		void add_shader(const std::string& filename);

		// Returns bitfield of shader stages that will be active in the program generated by this compiler.
		GLbitfield get_program_stages();

		// Compile a shader program from shader objects. Returns ID of generated program.
		GLuint link();

		// stores completed shader objects by type
		shaders_map shader_objects;

		// Used when compiling
		profile prof;
		unsigned int version;

	};
	
	template<typename shader_type>
	static void compile_shader(const std::string& filename, compiler& cl) {
		std::ifstream shader_stream;
		std::string shader_code;
		GLuint ID; // ID/name of generated shader
		// Open shader code file
		try {
			shader_stream.open(filename);
			std::stringstream tmp;
			tmp << shader_stream.rdbuf();
			shader_code = tmp.str();
			shader_stream.close();
		}
		catch (std::ifstream::failure e) {
			std::cerr << "Shader file not found, quitting" << std::endl;
		}

		std::vector<std::string> defines, includes;
		find_defines(shader_code, defines);
		find_includes(shader_code, includes);
		

		std::string final_code;
		final_code = std::string("#version ") + std::to_string(cl.version);
		final_code += profile_string(cl.prof);

		if (includes.size() != 0 || defines.size() != 0) {
			// Accumulate defines and includes into preprocessor_elems
			std::string preprocessor_elems;

			for (auto& str : defines) {
				preprocessor_elems += str;
			}
			for (auto& str : includes) {
				preprocessor_elems += str;
			}
			// Final code snippet, with preprocessor elements added.
			final_code += preprocessor_elems + shader_code;
		}
		else {
			// Create object
			final_code += shader_code;
		}

		// Generate object 
		ID = generate_shader_impl(typename shader_type::type());

		// Compile shader.
		char const* src = final_code.c_str();
		glShaderSource(ID, 1, &src, nullptr);
		glCompileShader(ID);

		// Check for compiliation errors
		GLint success;
		GLchar infoLog[1024];
		glGetShaderiv(ID, GL_COMPILE_STATUS, &success);
		if (!success) {
			glGetShaderInfoLog(ID, 1024, nullptr, infoLog);
			std::cout << "ERROR::" << filename << "::COMPILATION_FAILED\n" << infoLog << std::endl;
			throw(std::runtime_error("Shader compiliation failed"));
		}

		add_shader_impl(cl, ID, typename shader_type::type());
	}

	static GLuint generate_shader_impl(vertex_shader_t) {
		return glCreateShader(GL_VERTEX_SHADER);
	}

	static GLuint generate_shader_impl(fragment_shader_t) {
		return glCreateShader(GL_FRAGMENT_SHADER);
	}

	static GLuint generate_shader_impl(geometry_shader_t) {
		return glCreateShader(GL_GEOMETRY_SHADER);
	}

	static GLuint generate_shader_impl(tess_control_shader_t) {
		return glCreateShader(GL_TESS_CONTROL_SHADER);
	}

	static GLuint generate_shader_impl(tess_eval_shader_t) {
		return glCreateShader(GL_TESS_EVALUATION_SHADER);
	}

	static GLuint generate_shader_impl(compute_shader_t) {
		return glCreateShader(GL_COMPUTE_SHADER);
	}

	static void add_shader_impl(compiler& cl, const GLuint& shader_id, vertex_shader_t) {
		cl.shader_objects.insert(std::make_pair(GL_VERTEX_SHADER_BIT, shader_id));
	}

	static void add_shader_impl(compiler& cl, const GLuint& shader_id, fragment_shader_t) {
		cl.shader_objects.insert(std::make_pair(GL_FRAGMENT_SHADER_BIT, shader_id));
	}

	static void add_shader_impl(compiler& cl, const GLuint& shader_id, geometry_shader_t) {
		cl.shader_objects.insert(std::make_pair(GL_GEOMETRY_SHADER_BIT, shader_id));
	}

	static void add_shader_impl(compiler& cl, const GLuint& shader_id, tess_control_shader_t) {
		cl.shader_objects.insert(std::make_pair(GL_TESS_CONTROL_SHADER_BIT, shader_id));
	}

	static void add_shader_impl(compiler& cl, const GLuint& shader_id, tess_eval_shader_t) {
		cl.shader_objects.insert(std::make_pair(GL_TESS_EVALUATION_SHADER_BIT, shader_id));
	}

	static void add_shader_impl(compiler& cl, const GLuint& shader_id, compute_shader_t) {
		cl.shader_objects.insert(std::make_pair(GL_COMPUTE_SHADER_BIT, shader_id));
	}

	template<typename shader_type>
	inline void compiler::add_shader(const std::string & filename){
		compile_shader<shader_type>(filename, *this);
	}

	inline GLbitfield compiler::get_program_stages() {
		// Create bitfield defining stages.
		GLbitfield program_stages;
		for (const auto& shader : shader_objects) {
			program_stages |= shader.first;
		}
		return program_stages;
	}

	inline GLuint compiler::link(){
		GLuint program_id = glCreateProgram();
		// specify that this is a seperable program
		glProgramParameteri(program_id, GL_PROGRAM_SEPARABLE, GL_TRUE);
		// Attach shaders
		for (const auto& shader : shader_objects) {
			glAttachShader(program_id, shader.second);
		}
		// Link program
		glLinkProgram(program_id);
		// Check for errors.
		GLint success;
		GLchar infoLog[1024];
		// Print linking errors if any
		glGetProgramiv(program_id, GL_LINK_STATUS, &success);
		if (!success) {
			glGetProgramInfoLog(program_id, 1024, NULL, infoLog);
			std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
			throw(std::runtime_error("Shader program linking failed"));
		}
		return program_id;
	}

}

#endif // !VULPES_GLSL_COMPILER_H
